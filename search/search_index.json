{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n a la Tarea Bienvenido a la documentaci\u00f3n de esta actividad. El objetivo principal de este proyecto es registrar y explicar todos los pasos t\u00e9cnicos involucrados en la configuraci\u00f3n de un entorno de desarrollo y despliegue completo. Este sitio, generado est\u00e1ticamente mediante MkDocs , sirve como evidencia y gu\u00eda del proceso, abarcando desde la gesti\u00f3n del c\u00f3digo fuente hasta su automatizaci\u00f3n y despliegue en entornos de contenedores y nube. \u00cdndice de Contenidos Aqu\u00ed puedes navegar a las diferentes secciones que componen la documentaci\u00f3n de la tarea: Proceso Git Se detalla el proceso y las operaciones realizadas para la creaci\u00f3n y configuraci\u00f3n del repositorio en Git. Configuraci\u00f3n de GitHub Actions Documentaci\u00f3n de la creaci\u00f3n y comprobaci\u00f3n del WorkFlow (flujo de trabajo) para automatizar la construcci\u00f3n de la web est\u00e1tica con MkDocs. Configuraci\u00f3n de GitHub Pages Descripci\u00f3n del proceso de Despliegue Continuo (CD). Detalla c\u00f3mo se ha configurado el repositorio para alojar y servir la documentaci\u00f3n est\u00e1tica generada previamente por las Actions. Despliegue con Docker y Nginx Describe las operaciones de creaci\u00f3n y puesta en marcha del servicio NGinx en un contenedor Docker para mostrar la documentaci\u00f3n de la actividad. Conclusiones Apartado final con las conclusiones personales sobre el desarrollo de la actividad.","title":"Home"},{"location":"#introduccion-a-la-tarea","text":"Bienvenido a la documentaci\u00f3n de esta actividad. El objetivo principal de este proyecto es registrar y explicar todos los pasos t\u00e9cnicos involucrados en la configuraci\u00f3n de un entorno de desarrollo y despliegue completo. Este sitio, generado est\u00e1ticamente mediante MkDocs , sirve como evidencia y gu\u00eda del proceso, abarcando desde la gesti\u00f3n del c\u00f3digo fuente hasta su automatizaci\u00f3n y despliegue en entornos de contenedores y nube.","title":"Introducci\u00f3n a la Tarea"},{"location":"#indice-de-contenidos","text":"Aqu\u00ed puedes navegar a las diferentes secciones que componen la documentaci\u00f3n de la tarea:","title":"\u00cdndice de Contenidos"},{"location":"#proceso-git","text":"Se detalla el proceso y las operaciones realizadas para la creaci\u00f3n y configuraci\u00f3n del repositorio en Git.","title":"Proceso Git"},{"location":"#configuracion-de-github-actions","text":"Documentaci\u00f3n de la creaci\u00f3n y comprobaci\u00f3n del WorkFlow (flujo de trabajo) para automatizar la construcci\u00f3n de la web est\u00e1tica con MkDocs.","title":"Configuraci\u00f3n de GitHub Actions"},{"location":"#configuracion-de-github-pages","text":"Descripci\u00f3n del proceso de Despliegue Continuo (CD). Detalla c\u00f3mo se ha configurado el repositorio para alojar y servir la documentaci\u00f3n est\u00e1tica generada previamente por las Actions.","title":"Configuraci\u00f3n de GitHub Pages"},{"location":"#despliegue-con-docker-y-nginx","text":"Describe las operaciones de creaci\u00f3n y puesta en marcha del servicio NGinx en un contenedor Docker para mostrar la documentaci\u00f3n de la actividad.","title":"Despliegue con Docker y Nginx"},{"location":"#conclusiones","text":"Apartado final con las conclusiones personales sobre el desarrollo de la actividad.","title":"Conclusiones"},{"location":"conclusiones/","text":"Conclusiones de la Tarea La realizaci\u00f3n de esta actividad ha permitido poner en pr\u00e1ctica la integraci\u00f3n de m\u00faltiples tecnolog\u00edas fundamentales en el desarrollo de software moderno y la administraci\u00f3n de sistemas (DevOps). El objetivo no era solo aprender a usar cada herramienta de forma aislada, sino entender c\u00f3mo interact\u00faan para crear un flujo de trabajo automatizado y robusto. A continuaci\u00f3n, se resumen los aprendizajes clave obtenidos en cada fase del proyecto: Gesti\u00f3n de Versiones (Git y GitHub): Se ha reforzado la importancia de Git como pilar para el control de versiones. El uso de un repositorio centralizado en GitHub no solo sirve como copia de seguridad, sino como punto de partida para todas las automatizaciones posteriores. Automatizaci\u00f3n (GitHub Actions): La configuraci\u00f3n del flujo de trabajo (workflow) de GitHub Actions ha sido una de las partes m\u00e1s relevantes. Ha permitido comprender el concepto de Integraci\u00f3n Continua (CI), automatizando por completo el proceso de \"compilar\" el sitio de MkDocs cada vez que se realiza un cambio en la rama principal. Esto elimina el trabajo manual y asegura la consistencia. Documentaci\u00f3n como C\u00f3digo (MkDocs): El uso de MkDocs ha demostrado la eficiencia de la filosof\u00eda \"Docs-as-Code\". Tratar la documentaci\u00f3n (archivos Markdown) como parte del c\u00f3digo fuente del proyecto, version\u00e1ndola con Git y compil\u00e1ndola en un pipeline, facilita enormemente su mantenimiento y actualizaci\u00f3n. Contenerizaci\u00f3n (Docker y Nginx): La fase final con Docker y Nginx ha sido clave para entender la distribuci\u00f3n de una aplicaci\u00f3n. En lugar de configurar un servidor web manualmente, se ha creado una imagen de Docker que contiene un entorno Nginx preconfigurado para servir los archivos est\u00e1ticos generados por MkDocs. Esto garantiza que el sitio web se ejecute de la misma manera en cualquier entorno (local, pruebas, producci\u00f3n) gracias a la portabilidad de los contenedores. En resumen, la tarea ha proporcionado una visi\u00f3n completa \"end-to-end\" de un ciclo de vida de desarrollo: desde la escritura de contenido (Markdown) y su versionado (Git), pasando por la construcci\u00f3n automatizada (GitHub Actions), hasta el despliegue final en un servidor web (Nginx) encapsulado y distribuible (Docker).","title":"Conclusiones"},{"location":"conclusiones/#conclusiones-de-la-tarea","text":"La realizaci\u00f3n de esta actividad ha permitido poner en pr\u00e1ctica la integraci\u00f3n de m\u00faltiples tecnolog\u00edas fundamentales en el desarrollo de software moderno y la administraci\u00f3n de sistemas (DevOps). El objetivo no era solo aprender a usar cada herramienta de forma aislada, sino entender c\u00f3mo interact\u00faan para crear un flujo de trabajo automatizado y robusto. A continuaci\u00f3n, se resumen los aprendizajes clave obtenidos en cada fase del proyecto: Gesti\u00f3n de Versiones (Git y GitHub): Se ha reforzado la importancia de Git como pilar para el control de versiones. El uso de un repositorio centralizado en GitHub no solo sirve como copia de seguridad, sino como punto de partida para todas las automatizaciones posteriores. Automatizaci\u00f3n (GitHub Actions): La configuraci\u00f3n del flujo de trabajo (workflow) de GitHub Actions ha sido una de las partes m\u00e1s relevantes. Ha permitido comprender el concepto de Integraci\u00f3n Continua (CI), automatizando por completo el proceso de \"compilar\" el sitio de MkDocs cada vez que se realiza un cambio en la rama principal. Esto elimina el trabajo manual y asegura la consistencia. Documentaci\u00f3n como C\u00f3digo (MkDocs): El uso de MkDocs ha demostrado la eficiencia de la filosof\u00eda \"Docs-as-Code\". Tratar la documentaci\u00f3n (archivos Markdown) como parte del c\u00f3digo fuente del proyecto, version\u00e1ndola con Git y compil\u00e1ndola en un pipeline, facilita enormemente su mantenimiento y actualizaci\u00f3n. Contenerizaci\u00f3n (Docker y Nginx): La fase final con Docker y Nginx ha sido clave para entender la distribuci\u00f3n de una aplicaci\u00f3n. En lugar de configurar un servidor web manualmente, se ha creado una imagen de Docker que contiene un entorno Nginx preconfigurado para servir los archivos est\u00e1ticos generados por MkDocs. Esto garantiza que el sitio web se ejecute de la misma manera en cualquier entorno (local, pruebas, producci\u00f3n) gracias a la portabilidad de los contenedores. En resumen, la tarea ha proporcionado una visi\u00f3n completa \"end-to-end\" de un ciclo de vida de desarrollo: desde la escritura de contenido (Markdown) y su versionado (Git), pasando por la construcci\u00f3n automatizada (GitHub Actions), hasta el despliegue final en un servidor web (Nginx) encapsulado y distribuible (Docker).","title":"Conclusiones de la Tarea"},{"location":"docker/","text":"Despliegue de Documentaci\u00f3n con NGINX y Docker 1. Explicaci\u00f3n del proceso Para completar la actividad, el objetivo fue levantar un servicio web que sirviera los ficheros est\u00e1ticos generados por mkdocs alojados en la rama gh-pages del repositorio. El proceso realizado fue el siguiente: Me asegur\u00e9 de estar situado en la rama gh-pages del repositorio para tener acceso a los archivos HTML generados ( git checkout gh-pages ). Utilic\u00e9 el CLI de Docker para crear un contenedor basado en la imagen oficial de NGINX . Configur\u00e9 el contenedor con los siguientes par\u00e1metros mediante flags : --name : Nombr\u00e9 al contenedor PPSUnidad0-Tarea_Ivan_Muriel para su f\u00e1cil identificaci\u00f3n. -d : Ejecut\u00e9 el proceso en segundo plano (modo detached ). -p 8085:80 : Realic\u00e9 un redireccionamiento de puertos, mapeando el puerto 8085 de mi m\u00e1quina anfitriona al puerto 80 del contenedor (puerto por defecto de NGINX). -v \"$(pwd)\":/usr/share/nginx/html : Cre\u00e9 un volumen de tipo bind mount . Esto vincula mi directorio actual de trabajo (donde est\u00e1 la documentaci\u00f3n) con la carpeta ra\u00edz del servidor web dentro del contenedor. Esto permite que NGINX sirva mis archivos locales directamente. El comando final ejecutado fue: docker run -d --name PPSUnidad0-Tarea_Ivan_Muriel -p 8085:80 -v \"/$(pwd):/usr/share/nginx/html\" nginx:latest 2. Evidencias del despliegue A continuaci\u00f3n, se adjuntan las capturas de pantalla que demuestran el correcto funcionamiento del servicio. A. Creaci\u00f3n de la m\u00e1quina En esta captura se muestra la ejecuci\u00f3n del comando en la terminal y el ID del contenedor generado. B. Visualizaci\u00f3n de la p\u00e1gina web Accediendo a trav\u00e9s del navegador a http://localhost:8085 , se observa la documentaci\u00f3n cargada correctamente. C. Informaci\u00f3n del Contenedor (Docker Inspect) Detalle de la configuraci\u00f3n interna del contenedor, donde se puede verificar el montaje del volumen ( Mounts ) y la configuraci\u00f3n de red.","title":"Docker"},{"location":"docker/#despliegue-de-documentacion-con-nginx-y-docker","text":"","title":"Despliegue de Documentaci\u00f3n con NGINX y Docker"},{"location":"docker/#1-explicacion-del-proceso","text":"Para completar la actividad, el objetivo fue levantar un servicio web que sirviera los ficheros est\u00e1ticos generados por mkdocs alojados en la rama gh-pages del repositorio. El proceso realizado fue el siguiente: Me asegur\u00e9 de estar situado en la rama gh-pages del repositorio para tener acceso a los archivos HTML generados ( git checkout gh-pages ). Utilic\u00e9 el CLI de Docker para crear un contenedor basado en la imagen oficial de NGINX . Configur\u00e9 el contenedor con los siguientes par\u00e1metros mediante flags : --name : Nombr\u00e9 al contenedor PPSUnidad0-Tarea_Ivan_Muriel para su f\u00e1cil identificaci\u00f3n. -d : Ejecut\u00e9 el proceso en segundo plano (modo detached ). -p 8085:80 : Realic\u00e9 un redireccionamiento de puertos, mapeando el puerto 8085 de mi m\u00e1quina anfitriona al puerto 80 del contenedor (puerto por defecto de NGINX). -v \"$(pwd)\":/usr/share/nginx/html : Cre\u00e9 un volumen de tipo bind mount . Esto vincula mi directorio actual de trabajo (donde est\u00e1 la documentaci\u00f3n) con la carpeta ra\u00edz del servidor web dentro del contenedor. Esto permite que NGINX sirva mis archivos locales directamente. El comando final ejecutado fue: docker run -d --name PPSUnidad0-Tarea_Ivan_Muriel -p 8085:80 -v \"/$(pwd):/usr/share/nginx/html\" nginx:latest","title":"1. Explicaci\u00f3n del proceso"},{"location":"docker/#2-evidencias-del-despliegue","text":"A continuaci\u00f3n, se adjuntan las capturas de pantalla que demuestran el correcto funcionamiento del servicio.","title":"2. Evidencias del despliegue"},{"location":"docker/#a-creacion-de-la-maquina","text":"En esta captura se muestra la ejecuci\u00f3n del comando en la terminal y el ID del contenedor generado.","title":"A. Creaci\u00f3n de la m\u00e1quina"},{"location":"docker/#b-visualizacion-de-la-pagina-web","text":"Accediendo a trav\u00e9s del navegador a http://localhost:8085 , se observa la documentaci\u00f3n cargada correctamente.","title":"B. Visualizaci\u00f3n de la p\u00e1gina web"},{"location":"docker/#c-informacion-del-contenedor-docker-inspect","text":"Detalle de la configuraci\u00f3n interna del contenedor, donde se puede verificar el montaje del volumen ( Mounts ) y la configuraci\u00f3n de red.","title":"C. Informaci\u00f3n del Contenedor (Docker Inspect)"},{"location":"git/","text":"Creaci\u00f3n de Proyecto y Repositorio 1. Crear un nuevo repositorio p\u00fablico en GitHub Crea un repositorio con el nombre: PPS-Unidad0ActividadGit-TuNombre Debe ser p\u00fablico Debe contener un archivo README 2. Clonar el repositorio en tu equipo git clone git@github.com:$Tu_usuario_github/PPS-Unidad0ActividadGit-$TuNombre.git Si aparece el mensaje: The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. Are you sure you want to continue connecting (yes/no/[fingerprint])? Responde: yes Luego entra en la carpeta: cd PPS-Unidad0ActividadGit-$TuNombre 3. Estructura del proyecto Debe quedar as\u00ed: PPS-Unidad0ActividadGit-TuNombre/ \u251c\u2500\u2500 calculator/ \u2502 \u251c\u2500\u2500 init .py \u2502 \u2514\u2500\u2500 gui.py \u251c\u2500\u2500 docs/ \u2502 \u2514\u2500\u2500 index.md \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 requirements.txt 4. Crear la estructura mkdir calculator docs touch calculator/__init__.py calculator/gui.py docs/index.md mkdocs.yml requirements.txt ls -l * 5. Comprobar el estado del proyecto git status Ver\u00e1s archivos sin seguimiento. 6. A\u00f1adir archivos al \u00e1rea staged git add . Comprueba nuevamente: git status 7. Ver estructura en \u00e1rbol tree -a Ver\u00e1s la carpeta oculta .git que contiene la estructura interna de Git. 8. A\u00f1adir contenido a los archivos Edita los archivos: __init__.py gui.py index.md mkdocs.yml requirements.txt Y revisa el estado: git status Vuelve a a\u00f1adirlos: git add . 9. Confirmar los cambios (commit) git commit -am \"creando los archivos\" 10. Subir los cambios git push origin main Verifica en GitHub que todo est\u00e9 correcto. 11. Probar la calculadora Instalar Tkinter (si no lo tienes): sudo apt install python3-tk python3 calculator/gui.py Clonar un repositorio Crea una carpeta llamada: PPS-Unidad0ActividadGit-TuNombreCopia Entra en ella y clona: git clone git@github.com:$Tu_usuario_github/PPS-Unidad0ActividadGit-$TuNombre.git Borra esa carpeta y vuelve al proyecto original. Levantar un peque\u00f1o Servidor Web con PHP 1. Crear archivo HTML echo \"<h1> hola\u00a1\u00a1\u00a1 Bienvenidos a la clase de PPS</h1>\" >> index.html git add . git commit -am \"a\u00f1adido index.html\" 2. Levantar el servidor php -S 0:8080 Abre otra pesta\u00f1a del terminal. Visita: \ud83d\udc49 http://localhost:8080 3. Modificar index.html Edita el archivo y refresca el navegador para ver los cambios. 4. Ver estado y diferencias git status git diff index.html 5. Restaurar archivo a versi\u00f3n previa git restore index.html Refresca el navegador. 6. Confirmar y subir cambios git add . git commit -am \"actualizando proyecto\" git push 7. Mover archivo con git mv git mv index.html index.html.save Det\u00e9n el servidor PHP si sigue activo: Ctrl + C Git Log Consulta la documentaci\u00f3n: https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones Ver historial git log \u00daltimos 3 commits git log -3 Mostrar logs en una l\u00ednea git log --pretty=oneline \u00daltimos 2 commits con diferencias git log -p -2 Cambios del \u00faltimo d\u00eda git log --since=1.day Ramas 1. Ver ramas git branch --list 2. Eliminar archivo y guardar cambios git rm index.html.save git commit -am \"eliminando index.html.save\" git push origin main 3. Crear nueva rama dev git checkout -b dev Subirla al remoto: git push origin dev En GitHub puedes comparar las ramas y ver que tienen contenido diferente.","title":"Git"},{"location":"git/#creacion-de-proyecto-y-repositorio","text":"","title":"Creaci\u00f3n de Proyecto y Repositorio"},{"location":"git/#1-crear-un-nuevo-repositorio-publico-en-github","text":"Crea un repositorio con el nombre: PPS-Unidad0ActividadGit-TuNombre Debe ser p\u00fablico Debe contener un archivo README","title":"1. Crear un nuevo repositorio p\u00fablico en GitHub"},{"location":"git/#2-clonar-el-repositorio-en-tu-equipo","text":"git clone git@github.com:$Tu_usuario_github/PPS-Unidad0ActividadGit-$TuNombre.git Si aparece el mensaje: The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. Are you sure you want to continue connecting (yes/no/[fingerprint])? Responde: yes Luego entra en la carpeta: cd PPS-Unidad0ActividadGit-$TuNombre","title":"2. Clonar el repositorio en tu equipo"},{"location":"git/#3-estructura-del-proyecto","text":"Debe quedar as\u00ed: PPS-Unidad0ActividadGit-TuNombre/ \u251c\u2500\u2500 calculator/ \u2502 \u251c\u2500\u2500 init .py \u2502 \u2514\u2500\u2500 gui.py \u251c\u2500\u2500 docs/ \u2502 \u2514\u2500\u2500 index.md \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 requirements.txt","title":"3. Estructura del proyecto"},{"location":"git/#4-crear-la-estructura","text":"mkdir calculator docs touch calculator/__init__.py calculator/gui.py docs/index.md mkdocs.yml requirements.txt ls -l *","title":"4. Crear la estructura"},{"location":"git/#5-comprobar-el-estado-del-proyecto","text":"git status Ver\u00e1s archivos sin seguimiento.","title":"5. Comprobar el estado del proyecto"},{"location":"git/#6-anadir-archivos-al-area-staged","text":"git add . Comprueba nuevamente: git status","title":"6. A\u00f1adir archivos al \u00e1rea staged"},{"location":"git/#7-ver-estructura-en-arbol","text":"tree -a Ver\u00e1s la carpeta oculta .git que contiene la estructura interna de Git.","title":"7. Ver estructura en \u00e1rbol"},{"location":"git/#8-anadir-contenido-a-los-archivos","text":"Edita los archivos: __init__.py gui.py index.md mkdocs.yml requirements.txt Y revisa el estado: git status Vuelve a a\u00f1adirlos: git add .","title":"8. A\u00f1adir contenido a los archivos"},{"location":"git/#9-confirmar-los-cambios-commit","text":"git commit -am \"creando los archivos\"","title":"9. Confirmar los cambios (commit)"},{"location":"git/#10-subir-los-cambios","text":"git push origin main Verifica en GitHub que todo est\u00e9 correcto.","title":"10. Subir los cambios"},{"location":"git/#11-probar-la-calculadora","text":"Instalar Tkinter (si no lo tienes): sudo apt install python3-tk python3 calculator/gui.py","title":"11. Probar la calculadora"},{"location":"git/#clonar-un-repositorio","text":"Crea una carpeta llamada: PPS-Unidad0ActividadGit-TuNombreCopia Entra en ella y clona: git clone git@github.com:$Tu_usuario_github/PPS-Unidad0ActividadGit-$TuNombre.git Borra esa carpeta y vuelve al proyecto original.","title":"Clonar un repositorio"},{"location":"git/#levantar-un-pequeno-servidor-web-con-php","text":"","title":"Levantar un peque\u00f1o Servidor Web con PHP"},{"location":"git/#1-crear-archivo-html","text":"echo \"<h1> hola\u00a1\u00a1\u00a1 Bienvenidos a la clase de PPS</h1>\" >> index.html git add . git commit -am \"a\u00f1adido index.html\"","title":"1. Crear archivo HTML"},{"location":"git/#2-levantar-el-servidor","text":"php -S 0:8080 Abre otra pesta\u00f1a del terminal. Visita: \ud83d\udc49 http://localhost:8080","title":"2. Levantar el servidor"},{"location":"git/#3-modificar-indexhtml","text":"Edita el archivo y refresca el navegador para ver los cambios.","title":"3. Modificar index.html"},{"location":"git/#4-ver-estado-y-diferencias","text":"git status git diff index.html","title":"4. Ver estado y diferencias"},{"location":"git/#5-restaurar-archivo-a-version-previa","text":"git restore index.html Refresca el navegador.","title":"5. Restaurar archivo a versi\u00f3n previa"},{"location":"git/#6-confirmar-y-subir-cambios","text":"git add . git commit -am \"actualizando proyecto\" git push","title":"6. Confirmar y subir cambios"},{"location":"git/#7-mover-archivo-con-git-mv","text":"git mv index.html index.html.save Det\u00e9n el servidor PHP si sigue activo: Ctrl + C","title":"7. Mover archivo con git mv"},{"location":"git/#git-log","text":"Consulta la documentaci\u00f3n: https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones","title":"Git Log"},{"location":"git/#ver-historial","text":"git log","title":"Ver historial"},{"location":"git/#ultimos-3-commits","text":"git log -3","title":"\u00daltimos 3 commits"},{"location":"git/#mostrar-logs-en-una-linea","text":"git log --pretty=oneline","title":"Mostrar logs en una l\u00ednea"},{"location":"git/#ultimos-2-commits-con-diferencias","text":"git log -p -2","title":"\u00daltimos 2 commits con diferencias"},{"location":"git/#cambios-del-ultimo-dia","text":"git log --since=1.day","title":"Cambios del \u00faltimo d\u00eda"},{"location":"git/#ramas","text":"","title":"Ramas"},{"location":"git/#1-ver-ramas","text":"git branch --list","title":"1. Ver ramas"},{"location":"git/#2-eliminar-archivo-y-guardar-cambios","text":"git rm index.html.save git commit -am \"eliminando index.html.save\" git push origin main","title":"2. Eliminar archivo y guardar cambios"},{"location":"git/#3-crear-nueva-rama-dev","text":"git checkout -b dev Subirla al remoto: git push origin dev En GitHub puedes comparar las ramas y ver que tienen contenido diferente.","title":"3. Crear nueva rama dev"},{"location":"gitActions/","text":"Actividad Unidad 0 - gitActions Implementar una pipeline de Integraci\u00f3n Continua (CI) en GitHub Actions para automatizar la generaci\u00f3n y validaci\u00f3n de la documentaci\u00f3n de un proyecto Python cada vez que se actualiza el c\u00f3digo o la documentaci\u00f3n fuente. Integrar Herramientas: Configurar y utilizar GitHub Actions como motor de una pipeline de Integraci\u00f3n Continua (CI/CD). Automatizar la Calidad: Crear un flujo de trabajo que se dispare autom\u00e1ticamente con eventos clave (ej. git push ). Gesti\u00f3n de Dependencias: Utilizar comandos de Python ( pip ) dentro de la pipeline para instalar las dependencias necesarias de la aplicaci\u00f3n y la documentaci\u00f3n (ej., MkDocs ). Despliegue Continuo (CD B\u00e1sico): Demostrar un proceso de Despliegue Continuo al actualizar y publicar la documentaci\u00f3n en las GitHub Pages del proyecto. Fomentar DevSecOps: Aplicar la filosof\u00eda de que el mantenimiento y la validaci\u00f3n de la documentaci\u00f3n (una forma de \"calidad y consistencia\") deben ser un paso obligatorio y automatizado en el ciclo de vida del desarrollo. Desarrollo Lo primero que haremos ser\u00e1 instalar GitHub CLI . GiHug CLI (o gh ) es una herramienta de c\u00f3digo abierto que te permite usar GitHub directamente desde la l\u00ednea de comandos de tu terminal. Permite gestionar repositorios, solicitudes de extracci\u00f3n (pull requests), problemas, flujos de trabajo, lanzamientos y mucho m\u00e1s, sin necesidad de salir de tu entorno de l\u00ednea de comandos, lo que ahorra tiempo y facilita la automatizaci\u00f3n de tareas con scripts. Vamos a partir de la estructura del repositorio que hemos creado en la Actividad sobre el uso de Git. Recordamos que en ella hicimos un respositorio de una calculadora en Python. A part\u00edr de ah\u00ed vamos a crear un workflow de Github Actions . GitHub Actions es una plataforma de automatizaci\u00f3n integrada en GitHub que permite crear flujos de trabajo (workflows) para automatizar tareas de desarrollo de software, como la compilaci\u00f3n, las pruebas y el despliegue continuo (CI/CD). Se define mediante archivos YAML dentro del propio repositorio y puede ejecutarse en m\u00e1quinas virtuales de Linux, Windows o macOS, o en ejecutores auto-hospedado. En esta ocasi\u00f3n vamos a utilizar MkDocs para ver c\u00f3mo funciona el workflow . MkDocs es un generador de sitios est\u00e1ticos escrito en Python que permite crear r\u00e1pidamente sitios de documentaci\u00f3n para proyectos usando archivos en Markdown y un \u00fanico archivo de configuraci\u00f3n en YAML. Transforma el contenido de Markdown en p\u00e1ginas HTML, CSS y JavaScript, lo que facilita la generaci\u00f3n y publicaci\u00f3n de documentaci\u00f3n t\u00e9cnica de proyectos de c\u00f3digo abierto de manera eficiente. Paso 1: Preparaci\u00f3n del Proyecto y Documentaci\u00f3n 1. Estructura de Archivos Para que la generaci\u00f3n de la web funcione correctamente con el archivo de configuraci\u00f3n mostrado, la estructura de carpetas del proyecto debe ser la siguiente: PPS-Unidad0-Tarea-PPS/ \u251c\u2500\u2500 docs/ \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 git.md \u2502 \u251c\u2500\u2500 gitActions.md | \u251c\u2500\u2500 gitPages.md \u2502 \u251c\u2500\u2500 docker.md \u2502 \u251c\u2500\u2500 conclusiones.md \u2502 \u2514\u2500\u2500 img/ \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 .github/ \u2514\u2500\u2500 workflows/ \u2514\u2500\u2500 deploy_docs.yml 2. Configuraci\u00f3n de MkDocs Creamos (o editamos) el archivo mkdocs.yml en la ra\u00edz del proyecto con la configuraci\u00f3n adaptada a los contenidos de la unidad: # mkdocs.yml # ------------------------------------------------------------- # CONFIGURACI\u00d3N GENERAL DEL SITIO # ------------------------------------------------------------- site_name: PPS-Unidad0-Tarea-PPS-IvanMuriel # Define el t\u00edtulo que aparecer\u00e1 en la barra de navegaci\u00f3n y en la etiqueta <title> del navegador. # ------------------------------------------------------------- # ESTRUCTURA DE NAVEGACI\u00d3N (MEN\u00da) # ------------------------------------------------------------- # Define la lista de enlaces y el orden de aparici\u00f3n en el men\u00fa de navegaci\u00f3n principal. nav: # El nombre de la secci\u00f3n en el men\u00fa: nombre_archivo.md - Home: index.md # Primer elemento del men\u00fa, enlaza con el archivo 'index.md'. - Git: git.md - Git Actions: gitActions.md - Git Pages: gitPages.md - Docker: docker.md - Conclusiones: conclusiones.md # ------------------------------------------------------------- # DIRECTORIOS # ------------------------------------------------------------- # Ruta de la carpeta que contiene todos los archivos .md (Markdown) de la documentaci\u00f3n. # MkDocs buscar\u00e1 aqu\u00ed los archivos listados en 'nav'. doc_dir: docs # ------------------------------------------------------------- # TEMA (Opcional) # ------------------------------------------------------------- # theme: # name: 'material' # Si usas el popular tema Material for MkDocs. # # highlightjs: true # # code_fences: true Creaci\u00f3n del Workflow: Dentro del directorio .github/ , crea el directorio workflows/ y dentro de \u00e9l, el archivo deploy_docs.yml . Definici\u00f3n del Flujo de Trabajo (YAML): Pega la siguiente configuraci\u00f3n en deploy_docs.yml . Este workflow se dispara con cada push a la rama main (o master ) y utiliza una acci\u00f3n oficial para gestionar el despliegue de MkDocs a GitHub Pages. .github/workflows/deploy_docs.yml # ----------------------------------------------------------- # CONFIGURACI\u00d3N DEL WORKFLOW # ----------------------------------------------------------- name: Deploy MkDocs # Define el nombre de este flujo de trabajo (aparece en la pesta\u00f1a 'Actions' de GitHub). on: # Define el evento que dispara este flujo de trabajo. push: # Este workflow se ejecutar\u00e1 autom\u00e1ticamente cada vez que se haga un 'push' (subida) # de c\u00f3digo al repositorio. branches: - main # Espec\u00edficamente, solo se ejecuta si el push se realiza sobre la rama 'main'. # ----------------------------------------------------------- # PERMISOS # ----------------------------------------------------------- # Otorga permisos espec\u00edficos al GITHUB_TOKEN que se usar\u00e1 en este workflow. permissions: contents: write # Permite que el token pueda leer y escribir contenido (necesario para la rama gh-pages). pages: write # Permite gestionar y escribir en la configuraci\u00f3n de GitHub Pages. id-token: write # Permite solicitar tokens de OpenID Connect (necesario para algunas integraciones de seguridad). # ----------------------------------------------------------- # DEFINICI\u00d3N DEL TRABAJO (JOB) # ----------------------------------------------------------- jobs: deploy: # Define un \u00fanico trabajo llamado 'deploy'. runs-on: ubuntu-latest # Especifica que este trabajo se ejecutar\u00e1 en un servidor virtual con la \u00faltima versi\u00f3n de Ubuntu. steps: # La secuencia de comandos o acciones a ejecutar en el servidor de Ubuntu. # ------------------------------------------------------- # PASO 1: OBTENER EL C\u00d3DIGO FUENTE # ------------------------------------------------------- - name: Checkout Repo # Nombre descriptivo del paso. # Utiliza una acci\u00f3n oficial de GitHub para clonar el repositorio # completo en el entorno de trabajo del Runner. uses: actions/checkout@v3 # ------------------------------------------------------- # PASO 2: CONFIGURAR PYTHON # ------------------------------------------------------- - name: Set up Python # Nombre descriptivo del paso. # Utiliza una acci\u00f3n oficial para configurar el entorno de Python. uses: actions/setup-python@v4 with: python-version: '3.x' # Especifica que se debe usar la \u00faltima versi\u00f3n de Python 3. # ------------------------------------------------------- # PASO 3: INSTALAR DEPENDENCIAS # ------------------------------------------------------- - name: Install dependencies # Nombre descriptivo del paso. # Comando que se ejecuta en la terminal de Ubuntu. # Instala el generador de documentaci\u00f3n MkDocs (necesario para el siguiente paso). run: pip install mkdocs # ------------------------------------------------------- # PASO 4: CONSTRUIR Y DESPLEGAR LA DOCUMENTACI\u00d3N # ------------------------------------------------------- - name: Deploy docs # Nombre descriptivo del paso. # Comando que se ejecuta en la terminal. # 1. 'mkdocs gh-deploy': Construye la documentaci\u00f3n (generando los archivos HTML/CSS/JS). # 2. '--force': Sube esos archivos generados y fuerza su publicaci\u00f3n en la rama 'gh-pages'. run: mkdocs gh-deploy --force # Configuraci\u00f3n de variables de entorno espec\u00edficas para este paso. env: # Pasa el Token de GitHub. MkDocs lo necesita para autenticarse y subir # los archivos a la rama 'gh-pages' del repositorio. GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} Paso 3: Ejecuci\u00f3n y Verificaci\u00f3n Commit Inicial: Haz commit y push de los nuevos archivos . bash git add . git commit -m \" Configuraci\u00f3n inicial de MkDocs y pipeline CI/CD de documentaci\u00f3n\" git push origin main Monitoreo en GitHub: Ve a la pesta\u00f1a Actions de tu repositorio. Deber\u00edas ver el workflow \"Documentaci\u00f3n CI/CD\" ejecut\u00e1ndose.","title":"Git Actions"},{"location":"gitActions/#actividad-unidad-0-gitactions","text":"Implementar una pipeline de Integraci\u00f3n Continua (CI) en GitHub Actions para automatizar la generaci\u00f3n y validaci\u00f3n de la documentaci\u00f3n de un proyecto Python cada vez que se actualiza el c\u00f3digo o la documentaci\u00f3n fuente. Integrar Herramientas: Configurar y utilizar GitHub Actions como motor de una pipeline de Integraci\u00f3n Continua (CI/CD). Automatizar la Calidad: Crear un flujo de trabajo que se dispare autom\u00e1ticamente con eventos clave (ej. git push ). Gesti\u00f3n de Dependencias: Utilizar comandos de Python ( pip ) dentro de la pipeline para instalar las dependencias necesarias de la aplicaci\u00f3n y la documentaci\u00f3n (ej., MkDocs ). Despliegue Continuo (CD B\u00e1sico): Demostrar un proceso de Despliegue Continuo al actualizar y publicar la documentaci\u00f3n en las GitHub Pages del proyecto. Fomentar DevSecOps: Aplicar la filosof\u00eda de que el mantenimiento y la validaci\u00f3n de la documentaci\u00f3n (una forma de \"calidad y consistencia\") deben ser un paso obligatorio y automatizado en el ciclo de vida del desarrollo.","title":"Actividad Unidad 0 - gitActions"},{"location":"gitActions/#desarrollo","text":"Lo primero que haremos ser\u00e1 instalar GitHub CLI . GiHug CLI (o gh ) es una herramienta de c\u00f3digo abierto que te permite usar GitHub directamente desde la l\u00ednea de comandos de tu terminal. Permite gestionar repositorios, solicitudes de extracci\u00f3n (pull requests), problemas, flujos de trabajo, lanzamientos y mucho m\u00e1s, sin necesidad de salir de tu entorno de l\u00ednea de comandos, lo que ahorra tiempo y facilita la automatizaci\u00f3n de tareas con scripts. Vamos a partir de la estructura del repositorio que hemos creado en la Actividad sobre el uso de Git. Recordamos que en ella hicimos un respositorio de una calculadora en Python. A part\u00edr de ah\u00ed vamos a crear un workflow de Github Actions . GitHub Actions es una plataforma de automatizaci\u00f3n integrada en GitHub que permite crear flujos de trabajo (workflows) para automatizar tareas de desarrollo de software, como la compilaci\u00f3n, las pruebas y el despliegue continuo (CI/CD). Se define mediante archivos YAML dentro del propio repositorio y puede ejecutarse en m\u00e1quinas virtuales de Linux, Windows o macOS, o en ejecutores auto-hospedado. En esta ocasi\u00f3n vamos a utilizar MkDocs para ver c\u00f3mo funciona el workflow . MkDocs es un generador de sitios est\u00e1ticos escrito en Python que permite crear r\u00e1pidamente sitios de documentaci\u00f3n para proyectos usando archivos en Markdown y un \u00fanico archivo de configuraci\u00f3n en YAML. Transforma el contenido de Markdown en p\u00e1ginas HTML, CSS y JavaScript, lo que facilita la generaci\u00f3n y publicaci\u00f3n de documentaci\u00f3n t\u00e9cnica de proyectos de c\u00f3digo abierto de manera eficiente.","title":"Desarrollo"},{"location":"gitActions/#paso-1-preparacion-del-proyecto-y-documentacion","text":"","title":"Paso 1: Preparaci\u00f3n del Proyecto y Documentaci\u00f3n"},{"location":"gitActions/#1-estructura-de-archivos","text":"Para que la generaci\u00f3n de la web funcione correctamente con el archivo de configuraci\u00f3n mostrado, la estructura de carpetas del proyecto debe ser la siguiente: PPS-Unidad0-Tarea-PPS/ \u251c\u2500\u2500 docs/ \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 git.md \u2502 \u251c\u2500\u2500 gitActions.md | \u251c\u2500\u2500 gitPages.md \u2502 \u251c\u2500\u2500 docker.md \u2502 \u251c\u2500\u2500 conclusiones.md \u2502 \u2514\u2500\u2500 img/ \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 .github/ \u2514\u2500\u2500 workflows/ \u2514\u2500\u2500 deploy_docs.yml","title":"1. Estructura de Archivos"},{"location":"gitActions/#2-configuracion-de-mkdocs","text":"Creamos (o editamos) el archivo mkdocs.yml en la ra\u00edz del proyecto con la configuraci\u00f3n adaptada a los contenidos de la unidad: # mkdocs.yml # ------------------------------------------------------------- # CONFIGURACI\u00d3N GENERAL DEL SITIO # ------------------------------------------------------------- site_name: PPS-Unidad0-Tarea-PPS-IvanMuriel # Define el t\u00edtulo que aparecer\u00e1 en la barra de navegaci\u00f3n y en la etiqueta <title> del navegador. # ------------------------------------------------------------- # ESTRUCTURA DE NAVEGACI\u00d3N (MEN\u00da) # ------------------------------------------------------------- # Define la lista de enlaces y el orden de aparici\u00f3n en el men\u00fa de navegaci\u00f3n principal. nav: # El nombre de la secci\u00f3n en el men\u00fa: nombre_archivo.md - Home: index.md # Primer elemento del men\u00fa, enlaza con el archivo 'index.md'. - Git: git.md - Git Actions: gitActions.md - Git Pages: gitPages.md - Docker: docker.md - Conclusiones: conclusiones.md # ------------------------------------------------------------- # DIRECTORIOS # ------------------------------------------------------------- # Ruta de la carpeta que contiene todos los archivos .md (Markdown) de la documentaci\u00f3n. # MkDocs buscar\u00e1 aqu\u00ed los archivos listados en 'nav'. doc_dir: docs # ------------------------------------------------------------- # TEMA (Opcional) # ------------------------------------------------------------- # theme: # name: 'material' # Si usas el popular tema Material for MkDocs. # # highlightjs: true # # code_fences: true Creaci\u00f3n del Workflow: Dentro del directorio .github/ , crea el directorio workflows/ y dentro de \u00e9l, el archivo deploy_docs.yml . Definici\u00f3n del Flujo de Trabajo (YAML): Pega la siguiente configuraci\u00f3n en deploy_docs.yml . Este workflow se dispara con cada push a la rama main (o master ) y utiliza una acci\u00f3n oficial para gestionar el despliegue de MkDocs a GitHub Pages. .github/workflows/deploy_docs.yml # ----------------------------------------------------------- # CONFIGURACI\u00d3N DEL WORKFLOW # ----------------------------------------------------------- name: Deploy MkDocs # Define el nombre de este flujo de trabajo (aparece en la pesta\u00f1a 'Actions' de GitHub). on: # Define el evento que dispara este flujo de trabajo. push: # Este workflow se ejecutar\u00e1 autom\u00e1ticamente cada vez que se haga un 'push' (subida) # de c\u00f3digo al repositorio. branches: - main # Espec\u00edficamente, solo se ejecuta si el push se realiza sobre la rama 'main'. # ----------------------------------------------------------- # PERMISOS # ----------------------------------------------------------- # Otorga permisos espec\u00edficos al GITHUB_TOKEN que se usar\u00e1 en este workflow. permissions: contents: write # Permite que el token pueda leer y escribir contenido (necesario para la rama gh-pages). pages: write # Permite gestionar y escribir en la configuraci\u00f3n de GitHub Pages. id-token: write # Permite solicitar tokens de OpenID Connect (necesario para algunas integraciones de seguridad). # ----------------------------------------------------------- # DEFINICI\u00d3N DEL TRABAJO (JOB) # ----------------------------------------------------------- jobs: deploy: # Define un \u00fanico trabajo llamado 'deploy'. runs-on: ubuntu-latest # Especifica que este trabajo se ejecutar\u00e1 en un servidor virtual con la \u00faltima versi\u00f3n de Ubuntu. steps: # La secuencia de comandos o acciones a ejecutar en el servidor de Ubuntu. # ------------------------------------------------------- # PASO 1: OBTENER EL C\u00d3DIGO FUENTE # ------------------------------------------------------- - name: Checkout Repo # Nombre descriptivo del paso. # Utiliza una acci\u00f3n oficial de GitHub para clonar el repositorio # completo en el entorno de trabajo del Runner. uses: actions/checkout@v3 # ------------------------------------------------------- # PASO 2: CONFIGURAR PYTHON # ------------------------------------------------------- - name: Set up Python # Nombre descriptivo del paso. # Utiliza una acci\u00f3n oficial para configurar el entorno de Python. uses: actions/setup-python@v4 with: python-version: '3.x' # Especifica que se debe usar la \u00faltima versi\u00f3n de Python 3. # ------------------------------------------------------- # PASO 3: INSTALAR DEPENDENCIAS # ------------------------------------------------------- - name: Install dependencies # Nombre descriptivo del paso. # Comando que se ejecuta en la terminal de Ubuntu. # Instala el generador de documentaci\u00f3n MkDocs (necesario para el siguiente paso). run: pip install mkdocs # ------------------------------------------------------- # PASO 4: CONSTRUIR Y DESPLEGAR LA DOCUMENTACI\u00d3N # ------------------------------------------------------- - name: Deploy docs # Nombre descriptivo del paso. # Comando que se ejecuta en la terminal. # 1. 'mkdocs gh-deploy': Construye la documentaci\u00f3n (generando los archivos HTML/CSS/JS). # 2. '--force': Sube esos archivos generados y fuerza su publicaci\u00f3n en la rama 'gh-pages'. run: mkdocs gh-deploy --force # Configuraci\u00f3n de variables de entorno espec\u00edficas para este paso. env: # Pasa el Token de GitHub. MkDocs lo necesita para autenticarse y subir # los archivos a la rama 'gh-pages' del repositorio. GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}","title":"2. Configuraci\u00f3n de MkDocs"},{"location":"gitActions/#paso-3-ejecucion-y-verificacion","text":"Commit Inicial: Haz commit y push de los nuevos archivos . bash git add . git commit -m \" Configuraci\u00f3n inicial de MkDocs y pipeline CI/CD de documentaci\u00f3n\" git push origin main Monitoreo en GitHub: Ve a la pesta\u00f1a Actions de tu repositorio. Deber\u00edas ver el workflow \"Documentaci\u00f3n CI/CD\" ejecut\u00e1ndose.","title":"Paso 3: Ejecuci\u00f3n y Verificaci\u00f3n"},{"location":"gitPages/","text":"Actividad Unidad 0 - gitPages Esta documentaci\u00f3n creada sobre el proyecto se crear\u00e1 en la rama gh-pages de nuestro repositorio y vamos a aprovechar para publicar esta docuemtaci\u00f3n con Git Pages . Git Pages GitHub Pages es un servicio de alojamiento web que permite a los usuarios de GitHub publicar sitios web est\u00e1ticos (HTML, CSS, JavaScript) directamente desde un repositorio de Git, sin costo alguno. Es ideal para portafolios, blogs o p\u00e1ginas de proyectos, y no requiere experiencia previa en programaci\u00f3n o servidores. Uniendo esto con la secci\u00f3n gitActions, tenemos que cada vez que realizemos un git push en nuestro repositorio el workflow se va a disparar, haciendo que en nuestro equipo se construya la documentaci\u00f3n HTML del proyecto en su rama gh-pages y a la vez es subida, junto a los cambios realizados en la rama main, al repositorio de github. Esta documentaci\u00f3n la podremos visualizar a traves de GitHub Pages Activaci\u00f3n de GitHub Pages: Una vez que la pipeline se complete por primera vez, ve a Settings -> Pages en tu repositorio de GitHub y configura la fuente de despliegue a la rama gh-pages que la pipeline acaba de crear. Pulsamos el bot\u00f3n de save para que se guarden los cambios. Salimos para que se guarden los datos y tras unos minutos, en la secci\u00f3n de Pages tenemos: Verificaci\u00f3n Final: La documentaci\u00f3n deber\u00eda estar accesible en la URL de GitHub Pages ( ej. https://Tu_usuario_github.github.io/<repositorio>/ ). Podemos encontrarlo en Deployments /Github pages hacemos clic sobre ella y se mostrar\u00e1 el enlace para acceder a nuestra p\u00e1gina web est\u00e1tica.","title":"Git Pages"},{"location":"gitPages/#actividad-unidad-0-gitpages","text":"Esta documentaci\u00f3n creada sobre el proyecto se crear\u00e1 en la rama gh-pages de nuestro repositorio y vamos a aprovechar para publicar esta docuemtaci\u00f3n con Git Pages . Git Pages GitHub Pages es un servicio de alojamiento web que permite a los usuarios de GitHub publicar sitios web est\u00e1ticos (HTML, CSS, JavaScript) directamente desde un repositorio de Git, sin costo alguno. Es ideal para portafolios, blogs o p\u00e1ginas de proyectos, y no requiere experiencia previa en programaci\u00f3n o servidores. Uniendo esto con la secci\u00f3n gitActions, tenemos que cada vez que realizemos un git push en nuestro repositorio el workflow se va a disparar, haciendo que en nuestro equipo se construya la documentaci\u00f3n HTML del proyecto en su rama gh-pages y a la vez es subida, junto a los cambios realizados en la rama main, al repositorio de github. Esta documentaci\u00f3n la podremos visualizar a traves de GitHub Pages Activaci\u00f3n de GitHub Pages: Una vez que la pipeline se complete por primera vez, ve a Settings -> Pages en tu repositorio de GitHub y configura la fuente de despliegue a la rama gh-pages que la pipeline acaba de crear. Pulsamos el bot\u00f3n de save para que se guarden los cambios. Salimos para que se guarden los datos y tras unos minutos, en la secci\u00f3n de Pages tenemos: Verificaci\u00f3n Final: La documentaci\u00f3n deber\u00eda estar accesible en la URL de GitHub Pages ( ej. https://Tu_usuario_github.github.io/<repositorio>/ ). Podemos encontrarlo en Deployments /Github pages hacemos clic sobre ella y se mostrar\u00e1 el enlace para acceder a nuestra p\u00e1gina web est\u00e1tica.","title":"Actividad Unidad 0 - gitPages"}]}